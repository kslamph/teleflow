package teleflow

import (
	"strings"
	"sync"
)

// Package teleflow provides internal callback handling for inline keyboard button
// interactions within the Step-Prompt-Process API flow system.
//
// This file contains internal components that are tightly integrated with the flow
// system and inline keyboard callback handling. These components are not intended
// for direct use by end users and serve as the underlying infrastructure that
// enables the simplified keyboard API.
//
// The callback system abstracts away the complexity of Telegram's callback query
// handling, allowing users to define keyboards using simple maps in Prompt()
// functions and handle all input (both text and button clicks) through unified
// ProcessFunc functions.
//
// Internal Architecture:
//   - callbackHandler interface: Defines contract for callback processing
//   - callbackRegistry: Thread-safe registry managing callback handlers
//   - Automatic registration for flow-generated keyboards
//   - Pattern matching and routing of callback data to appropriate handlers
//   - Integration with the unified input processing system
//   - Transparent handling of button interactions without user intervention
//
// The system works in conjunction with PromptKeyboardHandler from keyboard_builder.go
// and integrates seamlessly with the flow system defined in flow.go.

// callbackHandler defines the internal interface for processing inline keyboard
// callback queries within the flow system.
//
// This interface is strictly for internal use and should never be implemented
// or used directly by end users. It serves as the contract for callback processing
// components that are automatically generated by the flow system's keyboard handling.
//
// The interface supports pattern-based callback routing, allowing handlers to
// match exact callback data or use wildcard patterns for flexible data extraction.
type callbackHandler interface {
	// pattern returns the string pattern that this handler matches against.
	//
	// The pattern can be:
	//   - An exact string for precise matching
	//   - A string ending with "*" to act as a wildcard prefix matcher
	//
	// Examples:
	//   - "button_action" matches only "button_action"
	//   - "user_*" matches "user_123", "user_456", etc.
	pattern() string

	// handle processes the callback query and executes the appropriate action.
	//
	// Parameters:
	//   - ctx: The current context containing user state and bot information
	//   - fullCallbackData: The complete callback data received from Telegram
	//   - extractedData: The data extracted after pattern matching (empty for exact matches)
	//
	// Returns an error if the callback processing fails.
	handle(ctx *Context, fullCallbackData string, extractedData string) error
}

// callbackRegistry manages a thread-safe registry of callback handlers for
// internal use within the flow system.
//
// This struct is the central component that coordinates callback handler
// registration, pattern matching, and callback routing. It maintains handlers
// that are typically generated by PromptKeyboardHandler and ensures thread-safe
// access in concurrent environments.
//
// The registry supports both exact pattern matching and wildcard pattern matching,
// enabling flexible callback data routing to appropriate handlers.
//
// Internal use only - not exposed to end users.
type callbackRegistry struct {
	// mu provides thread-safe access to the registry's internal state
	mu sync.RWMutex

	// handlers maps callback patterns to their corresponding handler implementations
	handlers map[string]callbackHandler

	// patterns maintains an ordered list of registered patterns for efficient matching
	patterns []string
}

// newCallbackRegistry creates and initializes a new callback registry.
//
// This function is used internally by the flow system to create registry
// instances for managing callback handlers. The returned registry is
// ready for thread-safe handler registration and callback processing.
//
// Internal use only - not exposed to end users.
//
// Returns a pointer to an initialized callbackRegistry with empty
// handler and pattern collections.
func newCallbackRegistry() *callbackRegistry {
	return &callbackRegistry{
		handlers: make(map[string]callbackHandler),
		patterns: []string{},
	}
}

// handle finds and executes the appropriate callback handler for the given callback data.
//
// This method performs pattern matching against all registered handlers and returns
// a HandlerFunc that wraps the execution of the matched callback handler. The method
// supports both exact pattern matching and wildcard prefix matching.
//
// Pattern Matching Logic:
//   - Exact match: Pattern equals callback data exactly
//   - Wildcard match: Pattern ends with "*" and callback data starts with pattern prefix
//
// Parameters:
//   - callbackData: The callback data string received from Telegram
//
// Returns:
//   - HandlerFunc: A function that executes the matched handler when called
//   - nil: If no matching handler is found
//
// The returned HandlerFunc integrates with the flow system's middleware chain
// and maintains compatibility with the existing handler architecture.
func (r *callbackRegistry) handle(callbackData string) HandlerFunc {
	r.mu.RLock()
	defer r.mu.RUnlock()

	for _, pattern := range r.patterns {
		if specificHandler := r.handlers[pattern]; specificHandler != nil {
			extractedData := r.matchPattern(pattern, callbackData)
			// A match occurs if:
			// 1. The pattern is an exact match to callbackData (extractedData will be "" from matchPattern, but it's a match).
			// 2. The pattern has a wildcard and callbackData matches the prefix (extractedData will be the part after the prefix).
			isExactMatch := (pattern == callbackData)
			isPrefixMatchWithWildcard := (strings.HasSuffix(pattern, "*") && extractedData != "" && strings.HasPrefix(callbackData, pattern[:len(pattern)-1]))

			if isExactMatch || isPrefixMatchWithWildcard {
				return func(ctx *Context) error {
					dataForHandler := extractedData
					if isExactMatch && extractedData == "" {
						dataForHandler = callbackData
					}
					return specificHandler.handle(ctx, callbackData, dataForHandler)
				}
			}
		}
	}
	return nil // No handler found
}

// matchPattern determines if callback data matches a given pattern and extracts
// relevant data based on the pattern type.
//
// Pattern Matching Rules:
//   - Wildcard patterns (ending with "*"): Extracts data after the prefix
//   - Exact patterns: Returns empty string for exact matches
//   - No match: Returns empty string
//
// Parameters:
//   - pattern: The pattern to match against (may contain wildcard "*")
//   - callbackData: The callback data to test and extract from
//
// Returns:
//   - string: Extracted data portion for wildcard matches, empty for exact matches or no match
//
// Examples:
//   - matchPattern("user_*", "user_123") returns "123"
//   - matchPattern("button", "button") returns ""
//   - matchPattern("user_*", "admin_456") returns ""
func (r *callbackRegistry) matchPattern(pattern, callbackData string) string {
	if strings.HasSuffix(pattern, "*") {
		prefix := pattern[:len(pattern)-1]
		if strings.HasPrefix(callbackData, prefix) {
			return callbackData[len(prefix):]
		}
	} else if pattern == callbackData {
		return ""
	}
	return ""
}
